# ProgramaciÃ³n AsÃ­ncrona en JavaScript ğŸš€

## setTimeout y setInterval â°

### setTimeout
`setTimeout` es una funciÃ³n que nos permite ejecutar cÃ³digo despuÃ©s de un tiempo determinado (en milisegundos).

```javascript
// Ejemplo bÃ¡sico de setTimeout
console.log("Â¡Inicio! ğŸ¬");

setTimeout(() => {
    console.log("Â¡Han pasado 2 segundos! âŒ›");
}, 2000);

console.log("Â¡Esto se muestra primero! ğŸ¥‡");
```

### setInterval
`setInterval` ejecuta una funciÃ³n repetidamente con un intervalo de tiempo fijo entre cada ejecuciÃ³n.

```javascript
// Ejemplo de setInterval
let contador = 0;
const intervalo = setInterval(() => {
    contador++;
    console.log(`Contador: ${contador} ğŸ”„`);
    
    if (contador >= 5) {
        clearInterval(intervalo); // Detener despuÃ©s de 5 iteraciones
        console.log("Â¡Intervalo terminado! ğŸ");
    }
}, 1000);
```

## Promises ğŸ¤

Las Promises (Promesas) son objetos que representan la eventual finalizaciÃ³n (o fallo) de una operaciÃ³n asÃ­ncrona.

### Estados de una Promise:
- Pending (Pendiente) â³
- Fulfilled (Cumplida) âœ…
- Rejected (Rechazada) âŒ

```javascript
// Creando una Promise
const miPromesa = new Promise((resolve, reject) => {
    const exito = true;
    
    if (exito) {
        resolve("Â¡OperaciÃ³n exitosa! ğŸ‰");
    } else {
        reject("Â¡Algo saliÃ³ mal! ğŸ˜¢");
    }
});

// Usando la Promise
miPromesa
    .then(resultado => console.log(resultado))
    .catch(error => console.log(error));

// Ejemplo prÃ¡ctico: Simulando una peticiÃ³n
function obtenerDatos() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const datos = { id: 1, nombre: "Usuario" };
            resolve(datos);
        }, 2000);
    });
}
```

## Async/Await ğŸŒŸ

`async/await` es una forma mÃ¡s elegante y legible de trabajar con Promises.

### CaracterÃ­sticas principales:
- `async`: Declara una funciÃ³n asÃ­ncrona
- `await`: Espera el resultado de una Promise

```javascript
// FunciÃ³n asÃ­ncrona bÃ¡sica
async function saludar() {
    return "Â¡Hola Mundo! ğŸ‘‹";
}

// Ejemplo prÃ¡ctico
async function obtenerUsuarios() {
    try {
        console.log("Iniciando bÃºsqueda... ğŸ”");
        
        // Simulamos una peticiÃ³n a una API
        const usuarios = await new Promise(resolve => {
            setTimeout(() => {
                resolve([
                    { id: 1, nombre: "Ana" },
                    { id: 2, nombre: "Carlos" }
                ]);
            }, 2000);
        });
        
        console.log("Â¡Usuarios encontrados! âœ¨", usuarios);
        return usuarios;
        
    } catch (error) {
        console.error("Â¡Error! ğŸ’¥", error);
    }
}

// Ejemplo de uso con mÃºltiples awaits
async function procesarDatos() {
    try {
        console.log("Iniciando proceso... ğŸ¯");
        
        // Primera operaciÃ³n asÃ­ncrona
        const datos = await obtenerDatos();
        console.log("Datos obtenidos:", datos);
        
        // Segunda operaciÃ³n asÃ­ncrona
        const resultadoProcesado = await procesarInformacion(datos);
        console.log("Resultado final:", resultadoProcesado);
        
    } catch (error) {
        console.error("Error en el proceso:", error);
    }
}

// FunciÃ³n helper para el ejemplo anterior
function procesarInformacion(datos) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve({
                ...datos,
                procesado: true,
                timestamp: new Date()
            });
        }, 1500);
    });
}
```

### Tips importantes ğŸ’¡

1. `async/await` hace que el cÃ³digo asÃ­ncrono parezca sÃ­ncrono
2. Siempre usa `try/catch` con async/await para manejar errores
3. `await` solo funciona dentro de funciones `async`
4. Puedes usar `Promise.all()` para ejecutar mÃºltiples promesas en paralelo:

```javascript
async function ejecutarEnParalelo() {
    const [resultado1, resultado2] = await Promise.all([
        obtenerDatos1(),
        obtenerDatos2()
    ]);
    
    console.log("Â¡Todos los datos obtenidos! ğŸŠ");
}
```

### Ventajas de usar async/await ğŸŒˆ

- CÃ³digo mÃ¡s limpio y fÃ¡cil de leer
- Mejor manejo de errores con try/catch
- Facilita el debugging
- Hace que el cÃ³digo asÃ­ncrono sea mÃ¡s intuitivo

Â¡Recuerda que la prÃ¡ctica hace al maestro! ğŸ¯âœ¨
